using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace VaaaN.MLFF.Libraries.CommonLibrary.Common
{
    public class CommonClass
    {
        #region Variables
        public static string storedProcedurePackagePrefix = "";
        public static string urlProtectPassword = "vaaan@123";
        public static string logFileDirectory = "C:/PMS/LOG/";
        #endregion

        #region Helper Methods

        public static void SaveToFolder(Image img, string extension, Size newSize, string pathToSave)
        {
            // Get new resolution Size 
            Size imgSize = NewImageSize(img.Size, newSize);
            using (System.Drawing.Image newImg = new Bitmap(img, imgSize.Width, imgSize.Height))
            {
                newImg.Save(pathToSave, img.RawFormat);
            }
        }
        private static Size NewImageSize(Size imageSize, Size newSize)
        {
            Size finalSize;
            double tempval;
            if (imageSize.Height > newSize.Height || imageSize.Width > newSize.Width)
            {
                if (imageSize.Height > imageSize.Width)
                    tempval = newSize.Height / (imageSize.Height * 1.0);
                else
                    tempval = newSize.Width / (imageSize.Width * 1.0);

                finalSize = new Size((int)(tempval * imageSize.Width), (int)(tempval * imageSize.Height));
            }
            else
            {
                // image is already small size
                finalSize = imageSize;
            }

            return finalSize;
        }
        /// <summary>
        /// Encrypt the string
        /// </summary>
        /// <param name="originalString"></param>
        /// <returns></returns>
        public static string Encrypt(string clearText)
        {
            string EncryptionKey = "vaaan@123";
            byte[] clearBytes = Encoding.Unicode.GetBytes(clearText);
            using (Aes encryptor = Aes.Create())
            {
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(EncryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
                encryptor.Key = pdb.GetBytes(32);
                encryptor.IV = pdb.GetBytes(16);
                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(clearBytes, 0, clearBytes.Length);
                        cs.Close();
                    }
                    clearText = Convert.ToBase64String(ms.ToArray());
                }
            }
            return clearText;
        }

        /// <summary>
        /// Decrypt the
        /// </summary>
        /// <param name="cryptedString"></param>
        /// <returns></returns>
        public static string Decrypt(string cipherText)
        {
            string EncryptionKey = "vaaan@123";
            cipherText = cipherText.Replace(" ", "+");
            byte[] cipherBytes = Convert.FromBase64String(cipherText);
            using (Aes encryptor = Aes.Create())
            {
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(EncryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
                encryptor.Key = pdb.GetBytes(32);
                encryptor.IV = pdb.GetBytes(16);
                using (MemoryStream ms = new MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(cipherBytes, 0, cipherBytes.Length);
                        cs.Close();
                    }
                    cipherText = Encoding.Unicode.GetString(ms.ToArray());
                }
            }
            return cipherText;
        }


        /// <summary>
        /// Secure the URL temparing in MVC
        /// </summary>
        /// <param name="controllerName"></param>
        /// <param name="actionName"></param>
        /// <param name="argumentParams"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public static string generateUrlToken(string controllerName, string actionName, string prm, string password)
        {
            string token = "";
            //The salt can be defined global
            string salt = "#cch@123";
            //generating the partial url
            string stringToToken = controllerName + "/" + actionName + "/";

            //The url token is generated by the same way it is generated for the link
            ArrayList argumentParams = new ArrayList();
            argumentParams.Add(prm);

            foreach (string param in argumentParams)
            {
                stringToToken += "/" + param;
            }
            //Converting the salt in to a byte array
            byte[] saltValueBytes = System.Text.Encoding.ASCII.GetBytes(salt);

            //Encrypt the salt bytes with the password
            Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(password, saltValueBytes);

            //get the key bytes from the above process
            byte[] secretKey = key.GetBytes(16);

            //generate the hash
            HMACSHA1 tokenHash = new HMACSHA1(secretKey);
            tokenHash.ComputeHash(System.Text.Encoding.ASCII.GetBytes(stringToToken));

            //convert the hash to a base64string
            token = Convert.ToBase64String(tokenHash.Hash).Replace(" ", "+");
            return token;
        }

        //public static void LogMessage(string msg)
        //{
        //    for (int i = 0; i < 5; i++)
        //    {
        //        try
        //        {
        //            if (!Directory.Exists(logFileDirectory))
        //            {
        //                Directory.CreateDirectory(logFileDirectory);
        //            }

        //            using (StreamWriter sw = new StreamWriter("C:/MLFF/LOG/MLFF.txt", true))
        //            {
        //                sw.WriteLine(DateTime.Now + ": " + msg);
        //            }
        //            break;
        //        }
        //        catch
        //        {
        //            // Ignore
        //        }
        //    }
        //}

        #endregion
    }
}
